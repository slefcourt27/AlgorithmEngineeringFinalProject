# -*- coding: utf-8 -*-
"""Algorithm Engineering Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SrIBvpGkFKG9gCF_G-xH13TqyTsOeSHR
"""

# -*- coding: utf-8 -*-
"""
Doubly Linked List Implementation (https://www.geeksforgeeks.org/doubly-linked-list/)
"""
import random

# A linked list node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
        self.id = data
        self.weight = 1

# Class to create a Doubly Linked List
class DoublyLinkedList:

    # Constructor for empty Doubly Linked List
    def __init__(self):
        self.head = None
        self.tail = None
        self.num_items = 0
        self.color = -1

    def exists(self, element):
        node = self.head
        while node:
            if node.data == element:
                return True
            node = node.next
        return False
    # Function to delete a node in a Doubly Linked List.
   # head_ref --> pointer to head node pointer.
   # dele --> pointer to node to be deleted

    def deleteNode(self, dele):
        # if self.exists(dele) == False:
        #     print(dele.data, "does not exist here.")
        #     return
        # Base Case
        if self.head is None or dele is None:
            return

        # If node to be deleted is head node
        if self.head == dele:
            self.head = dele.next

        # Change next only if node to be deleted is NOT
        # the last node
        if dele.next is not None:
            dele.next.prev = dele.prev

        # Change prev only if node to be deleted is NOT
        # the first node
        if dele.prev is not None:
            dele.prev.next = dele.next
        # Finally, free the memory occupied by dele
        self.num_items -= 1

    # Given a reference to the head of a list and an
    # integer, inserts a new node on the front of list
    def push(self, new_data):

        # 1. Allocates node
        # 2. Put the data in it
        new_node = Node(new_data)

        # 3. Make next of new node as head and
        # previous as None (already None)
        new_node.next = self.head

        # 4. change prev of head node to new_node
        if self.head is not None:
            self.head.prev = new_node

        # 5. move the head to point to the new node
        self.head = new_node

    # Given a node as prev_node, insert a new node after
    # the given node
    def insertAfter(self, prev_node, new_data):

        # 1. Check if the given prev_node is None
        if prev_node is None:
            print("the given previous node cannot be NULL")
            return

        # 2. allocate new node
        # 3. put in the data
        new_node = Node(new_data)

        # 4. Make net of new node as next of prev node
        new_node.next = prev_node.next

        # 5. Make prev_node as previous of new_node
        prev_node.next = new_node

        # 6. Make prev_node ass previous of new_node
        new_node.prev = prev_node

        # 7. Change previous of new_nodes's next node
        if new_node.next:
            new_node.next.prev = new_node

    # Given a reference to the head of DLL and integer,
    # appends a new node at the end
    def append(self, new_data):

        # 1. Allocates node
        # 2. Put in the data
        new_node = Node(new_data)
        if type(new_data) == Node:
            # print("appending node")
            new_node = new_data

        self.num_items += 1
        # 3. This new node is going to be the last node,
        # so make next of it as None
        # (It already is initialized as None)

        # 4. If the Linked List is empty, then make the
        # new node as head
        if self.head is None:
            self.head = new_node
            self.tail = new_node
            return

        self.tail.next = new_node
        new_node.prev = self.tail
        self.tail = new_node
        return

    # This function prints contents of linked list
    # starting from the given node
    def printList(self, node=None):
        if node is None:
            node = self.head

        if self.num_items == 0:
            print("Empty")
            return
        while node:
            print(node.data,'-> ',end='')
            last = node
            node = node.next
        print()
    def pop(self):
      id = self.tail.data

      self.tail.prev = self.tail
      return id
    def getData(self):
      node = self.head
      data = Array()
      while node:
        data.insert(node.data)
        last = node
        node = node.next
      return data

import sys
max = sys.maxsize
"""Custom Array Implementation <br>
Used part of https://codezup.com/create-own-custom-array-implementation-python/

"""

from random import randrange

# and my own function definitions
class Array(object):
    def __init__(self, size=max, fill=False, defaultValue = None):
        self.size = size
        self.len = 0
        self.items = list()

        if fill is True:
          count = 0
          while count < size:
            self.items[count] = -1

        if defaultValue is not None:
            self.len = len(self.items)
            if(len(defaultValue) == size or len(defaultValue) < size):
                for j in range(len(defaultValue)):
                    if(defaultValue[j]):
                        self.items.append(defaultValue[j])
                for i in range(len(defaultValue), size):
                    self.items.append(None)
            else:
                print('Elements are more than the size specified')

    def grow(self, until, insertArray=False, insertDLL=False):
      while self.myLen()-1 < until:
        if insertArray:
          self.insert(Array())
        elif insertDLL:
          self.insert(DoublyLinkedList())
        else:
          self.insert(-1)
    def exists(self, element):
      for i in range(self.myLen()):
        if self.items[i] == element:
          return True

      return False

    def myLen(self):
        return self.len

    def insert(self, element):
        # if self.myLen() < self.size:
        idx = self.myLen() - 1
        self.insertAfterIndex(idx, element)
        return

    def insertFirst(self, element):
        if (self.myLen() < self.size):
            for i in range(self.myLen(), 0, -1):
                self.items[i] = self.items[i - 1]
            self.items[0] = element
            self.len += 1
        else:
            print('Element index out of range')

    def insertAtIndex(self, index, element):
        if (self.myLen() < self.size):
            for i in range(self.myLen(), index, -1):
                self.items[i] = self.items[i - 1]
            self.items[index] = element
            self.len += 1
        else:
            print('Element index out of range')

    def insertAfterIndex(self, index, element):
        if index == self.myLen()-1:
            self.items.append(element)
            self.len += 1

        elif (self.myLen() < self.size):
            for i in range(self.myLen(), index + 1, -1):
                self.items[i] = self.items[i - 1]
            self.items[index + 1] = element
            self.len += 1
        else:
            print(self.myLen(), self.size)
            print('Element index out of range')

    def insertBeforeIndex(self, index, element):
        if (self.myLen() < self.size):
            for i in range(self.myLen(), index - 1, -1):
                self.items[i] = self.items[i - 1]
            self.items[index - 1] = element
            self.len += 1
        else:
            print('Element index out of range')

    def delete(self, element):
        if element in self.items:
            Index = self.items.index(element)
            self.items[Index] = None
            self -= 1
        else:
            print('This element is not in the Array!')

    def remove_element(self, element):
      self.items = [i for i in self.items if i != element]

    def search(self, element):
        if element in self.items:
            position = 0
            for i in range(self.myLen()):
                if(self.items[i] == element):
                    break
                else:
                    position += 1

            print('Element {} found at position {}'.format(element, position))
        else:
            print('This element is not in the Array!')

    # allow indexing
    def __getitem__(self, key):
        return self.items[key]

    def __setitem__(self, key, value):
        self.items[key] = value

    def set(self, index, ele):
      self.items[index] = ele
      return

    def at(self, index):
      return self.items[index]

    def extend(self, new_array):
      for item in new_array.items:
        self.insert(item)


import time
import matplotlib.pyplot as plt

def get_graph_name(graph_type):
    name = ''
    if graph_type == 0:
        name = 'cycle'
    elif graph_type ==1:
        name = 'complete'
    elif graph_type == 2:
        name = 'uniform'
    elif graph_type ==3:
        name = 'skew_low'
    elif graph_type == 4:
        name = 'skew_high'
    return name

def plot(x, y, graph_type, folder='', make_table=True, order='SLVO'):
    name = get_graph_name(graph_type)
    plt.plot(x.items, y.items)
    plt.xlabel("Vertex Amount")
    if folder == 'terminal':
        plt.title(name)
        plt.ylabel("Terminal Clique Size")
    elif folder == 'degree':
        plt.title(name)
        plt.ylabel("Max Degree when Deleted")
    else:
        plt.title(name)
        plt.ylabel("Execution Time (s)")

    if folder == 'color':
        plt.title('Time Needed to Color '+ name + ' with ' + order + ' ordering')

    elif folder == 'order':
        txt = 'Time Needed to Order ' + name + ' Using '+order
        plt.title(txt)

    if folder != '':
        folder = folder+'/'


    plt.savefig('./plots/'+folder+name)
    plt.clf()
    if make_table:
        table(x, y, graph_type, folder)

def table(x, y, graph_type, folder=''):
    fig, ax =plt.subplots(1,1)
    if folder != '':
        folder = folder+'/'
    # Have to make it a 2D list
    data = Array()
    for i in range(x.myLen()):
        data.insert([x[i], y[i]])
    column_labels=["Number of Vertices", "Time Taken(s)"]
    ax.axis('tight')
    ax.axis('off')
    ax.table(cellText=data.items,colLabels=column_labels,loc="center")

    name = get_graph_name(graph_type)
    plt.savefig('./tables/'+folder+name)
    plt.clf()

def histograph(adj_list, graph_type):
    edge_count = Array()
    for i in range(adj_list.myLen()):
        edge_count.insert(adj_list[i].num_items)

    name = get_graph_name(graph_type)
    num_bins = 10
    n, bins, patches = plt.hist(edge_count.items, num_bins, facecolor='blue', alpha=0.5,
                                rwidth=0.3)
    plt.xlabel("Number of edges")
    plt.ylabel("Number of vertices")
    plt.savefig('./histogram/'+name)

# Program 1
# Create program accepts number vertices
# Create undirected complete graph with V vertices
# Output graph in format below
# All edges should have weight of 1
# Create chart showing run times for various values
# Create graph of running times vs. various values (USE LINEAR SCALE ON AXIS)
# Describe how the running times support your analysis of the asymptotic running times
def undirected_complete_graph(v):

  # Create adjacency list
  aj_list = Array(v)

  # Create list of numbers 1->V
  vertices = Array(v)

  P = Array(v)

  # Calculate number of edges for a complete graph with V vertices
  edges = int((v * (v-1)) / 2)

  E = Array(edges * 2)
  for i in range(v):
    aj_list.insert(DoublyLinkedList())
    vertices.insert(i)

  # Connect the vertices
  count = 1

  for i in range(v):
    P.insert(count)
    for j in range(v):
      if j != i:
        aj_list[i].append(vertices[j])
        E.insert(j)
        count += 1

  return P, E, aj_list

# Program 2
# Create a cycle with V vertices using an adjacency list
def cycle(v):
  if v == 1 or v == 2:
    return 'Error - Invalid Input'

  # Create adjacency list
  aj_list = Array(v)

  # Create list of numbers 1->V
  vertices = Array(v)

  P = Array(v)
  E = Array(v*2)
  for i in range(v):
    aj_list.insert(DoublyLinkedList())
    vertices.insert(i)

  # Connect the vertices in a cyclic manner
  count = 1
  for i in range(v):
    P.insert(count)
    if i == (v-1):
      aj_list[i].append(0) # Connect back to beginning
      E.insert(0)
      count += 1
    else:
      aj_list[i].append(vertices[i+1])
      E.insert(vertices[i+1])
      count += 1

  return P, E, aj_list


# Accepts the nmuber of conflicts between pairs of vertices for "random" graphs
def uniform_distribution(E, V):
  vertices = Array()
  adj_list = Array()
  for i in range(V):
      adj_list.insert(DoublyLinkedList())

  while vertices.myLen() < 2*E:
    # Uniformly select a new vertex
    new_pair = False
    while new_pair == False:
        v1 = random.randint(0, V-1)
        v2 = random.randint(0, V-1)

        if v1 == v2:
            continue
        elif adj_list[v1].exists(v2) or adj_list[v2].exists(v1):
            continue
        else:
            new_pair = True
            # print("Found new pair: ", v1, v2)
            vertices.insert(v1)
            vertices.insert(v2)
            adj_list[v1].append(v2)
            adj_list[v2].append(v1)

  return vertices, adj_list

# Lower numbered vertices are linearly more likely than higher numbered vertices
def skewed_distribution(E, V):
  # Create new list
  # Each lower number will have some X entries
  # if we have 5 vertices
  # 0,0,0,0,0 1,1,1,1 2,2,2 3,3 4

  # Creating the new array
  entries = V
  skewed_list = Array()
  for i in range(V):
    j = 0
    while j < entries:
      skewed_list.insert(i)
      j+=1

    entries -= 1

  # Select 2*E Indices and get the value at that index
  vertices = Array()

  adj_list = Array()
  for i in range(V):
      adj_list.insert(DoublyLinkedList())

  while vertices.myLen() < 2*E:
    # Uniformly select a new vertex
    new_pair = False
    while new_pair == False:
        v1 = skewed_list[random.randint(0,skewed_list.myLen()-1)]
        v2 = skewed_list[random.randint(0,skewed_list.myLen()-1)]
        if v1 == v2:
            continue
        elif adj_list[v1].exists(v2) or adj_list[v2].exists(v1):
            continue
        else:
            new_pair = True
            # print("Found new pair: ", v1, v2)
            vertices.insert(v1)
            vertices.insert(v2)

            adj_list[v1].append(v2)
            adj_list[v2].append(v1)

  return vertices, adj_list

# My custom distribution will be the opposite of the skewed distribution
# Where larger numbers have a higher chance of being chosen for conflict

def custom_distribution(E, V):
  # Create new list
  # Each higheer number will have some X entries
  # if we have 5 vertices
  # 0,1,1,2,2,2,3,3,3,3,4,4,4,4,4
  # Creating the new array
  entries = V
  skewed_list = Array()
  for i in reversed(range(V)):
    j = 0
    while j < entries:
      skewed_list.insert(i)
      j += 1

    entries -= 1

  # Select 2*E Indices and get the value at that index
  vertices = Array()
  adj_list = Array()
  for i in range(V):
      adj_list.insert(DoublyLinkedList())

  while vertices.myLen() < 2*E:
    # Uniformly select a new vertex
    new_pair = False
    while new_pair == False:
        v1 = skewed_list[random.randint(0,skewed_list.myLen()-1)]
        v2 = skewed_list[random.randint(0,skewed_list.myLen()-1)]
        if v1 == v2:
            continue
        elif adj_list[v1].exists(v2) or adj_list[v2].exists(v1):
            continue
        else:
            new_pair = True
            # print("Found new pair: ", v1, v2)
            vertices.insert(v1)
            vertices.insert(v2)

            adj_list[v1].append(v2)
            adj_list[v2].append(v1)

  return vertices, adj_list

def write_to_file(v, P,E, ftype):
  # Accepts the P and E arrays
  # Outputs to file
  fname = "./files/"+ftype+".txt"
  f = open(fname, "w")

  # Number of vertices
  f.write( str(v) )
  f.write('\n')
  # Starting location for vertices
  for i in range(v):
      f.write( str( P[i] + v + 1))
      f.write('\n')


  for i in range(E.myLen()):
      f.write( str(E[i]) )
      f.write(" ")
      f.write(str(1))
      f.write('\n')

  f.close()

# Create graph from vertices generated from distribution
def create_graph_from_adjacency_list(v, adj_list):
  # Create adjacency list
  P = Array()
  E = Array()

  # Create E and P
  count=1
  # don't go thru vertex, do the indices lol dummy
  for vertex in range(v):
    P.insert(count)
    connected_vertices = adj_list[vertex].getData()
    E.extend(connected_vertices)
    count += connected_vertices.myLen()

  return P, E, adj_list

def generate_graph(graph_type, v, e, write, histogram):
    # Create graph
    name = ''
    if graph_type == 0:
        P, E, adj_list = cycle(v)
        name = "cycle_"+str(v)
    elif graph_type ==1:
        P, E, adj_list = undirected_complete_graph(v)
        name = "complete_"+str(v)
    elif graph_type ==2:
        vertices, adj_list = uniform_distribution(e, v)
        name = "uniform_"+str(v)+"_"+str(e)
        P, E, adj_list = create_graph_from_adjacency_list(v, adj_list)
    elif graph_type ==3:
        vertices, adj_list = skewed_distribution(e,v)
        name = "skew_low_"+str(v)+"_"+str(e)
        P, E, adj_list = create_graph_from_adjacency_list(v, adj_list)
    elif graph_type ==4:
        vertices, adj_list = custom_distribution(e,v)
        name = "skew_high_"+str(v)+"_"+str(e)
        P, E, adj_list = create_graph_from_adjacency_list(v, adj_list)

    if write:
        write_to_file(v, P, E, name)
    if histogram:
        histograph(adj_list, graph_type)

    return name

###############################################################################
###############################################################################
###############################################################################

# Part 2

class Vertex():
  def __init__(self, id):
    # Field 1
    self.id = id
    # Field 2
    self.edge_list_ptr = -1 # Pointer to edge list will be the index NOTE
    # Field 3
    self.color = -1
    self.degree = 0
    # Field 4
    self.same_degree_ptr = -1 # Index
    self.order_deleted_list_ptr = -1

def create_graph_from_file_input(fname):
    # print("Create graph from file input")
    line_number = 1
    num_vertices = 0

    # Create file reader
    f = open(fname, "r")
    num_vertices = int(f.readline())
    line_number += 1

    P = Array()
    E = Array()

    # Init adjacency list
    adj_list = Array()

    created_vertices = Array()

    for i in range(num_vertices):
      adj_list.insert(DoublyLinkedList()) # Edge list
      created_vertices.insert(Vertex(i)) # Creating vertex


    curr_vertex = 0
    # Read where the connections begin
    while curr_vertex < num_vertices:
      line = f.readline()
      P.insert(int(line[:-1]))
      line_number += 1
      curr_vertex += 1

    # print(P.items)
    curr_vertex = 0
    # Create list of DLL of vertices of same current degree
    degree_list = Array()

    # Read in edges for current vertex
    while True:
      skip = False
      # print("Line number", line_number)
      # print("Curr vertex", curr_vertex)
      curr_degree = created_vertices[curr_vertex].degree
      if curr_vertex == P.myLen()-1:
          skip = True

      if skip is False:
          # Check for empty
          # print(line_number)
          while line_number == P[curr_vertex +1]:

            created_vertices[curr_vertex].edge_list_ptr = curr_vertex # storing idx location in
            # Add this vertex to corresponding DLL of same degree
            curr_degree = created_vertices[curr_vertex].degree
            if degree_list.myLen()-1 < curr_degree:
              # Grow
              print("(1) Grow to", curr_degree, "for vertex", curr_vertex)
              degree_list.grow(curr_degree, insertDLL=True)

            # print("Appending current vertex", curr_vertex, "in file input ")
            degree_list[curr_degree].append(curr_vertex)
            curr_vertex += 1
            if curr_vertex == P.myLen()-1:
                # print("Curr vertex", curr_vertex)
                break

      # NOTE ON WHITESPACE WHAT IF NO EDGES
      line = f.readline() # string
      if line == '':
          curr_degree = created_vertices[curr_vertex].degree
          if degree_list.myLen()-1 < curr_degree:
            # Grow
            print("Grow to ", curr_degree)
            degree_list.grow(curr_degree, insertDLL=True)

          degree_list[curr_degree].append(curr_vertex)
          # print("Current degree is", curr_degree, "adding", curr_vertex)
          break

      # Break up the line by space
      line_list = []
      buffer = ""
      for idx in range(len(line)):
          char = line[idx]
          if char == " ":
              line_list.append(buffer)
              buffer = ""
          elif idx == len(line)-1:
              buffer += char
              line_list.append(buffer)
          else:
              buffer += char

      adjacent_vertex = int(line_list[0])
      weight = int(line_list[1])
      # print("Adjacent vertex is", adjacent_vertex)
      # print("Current vertex is", curr_vertex)
      # print("Appending adjacent vertex file input")
      adj_list[curr_vertex].append(adjacent_vertex)
      created_vertices[curr_vertex].degree += 1
      line_number += 1

    # degree_list[2].printList(degree_list[2].head)
    return created_vertices, degree_list, adj_list

def smallest_last_vertex_ordering(vertices, degree_list, adj_list):
  # Vertices is a list of Vertex objects
  # Degree list is a list of DLL with integers
  # Essentially takes the create_graph_from_file_input output and performs
  # smallest last vertex ordering on it
  # print("Performing SLVO")
  # print("===============")
  # print("Checking degree list")

  removed_vertices = 0
  deleted_list = Array()
  deleted_degree_list = Array() # Consisting of the degrees when removed
  max_degree_when_deleted = -1
  # Iteratively delete a vertex of smallest degree
  while removed_vertices != vertices.myLen():
    checking_degree = 0
    # print('--------------------------------')
    # for id, vertex in enumerate(vertices.items):
        # print("vertex", id, "has degree", vertex.degree, end=' | ')
    while degree_list[checking_degree].num_items == 0:
        checking_degree += 1
        # print("Checking degree", checking_degree)
        # print("Removed", removed_vertices, "vertices")
        # print("Degree list length:", degree_list.myLen())

        # print("Number of Vertices removed", removed_vertices)
        # print("num items in degree list of ", checking_degree, degree_list[checking_degree].num_items)

    # print()
    # print("Using degree", checking_degree)
    # Remove head

    vertex_removed = degree_list[checking_degree].head
    # print("Removing vertex", vertex_removed.data, " has id", vertex_removed.id)

    # Update the position in degree_list
    degree_list[checking_degree].deleteNode(vertex_removed)
    # Update the deleted degree list so I can find terminal clique later
    deleted_degree_list.insert(checking_degree)

    # Update the current degree
    if checking_degree > max_degree_when_deleted:
      max_degree_when_deleted = checking_degree

    # Update deleted list
    deleted_list.insert(vertex_removed)
    # Update vertex
    vertices[vertex_removed.id].degree = -1
    # Update number of removed vertices
    removed_vertices += 1

    # Update every connected vertex
    # print("ID", vertex_removed.data,"has edge list:")
    idx = vertices[vertex_removed.data].edge_list_ptr
    dll = adj_list[idx]
    # print("Edge list")
    node = dll.head
    while node is not None: # node is connected vertex
      node_degree = vertices[node.data].degree
      # print(node.data, "has degree", node_degree)
    #  Update this vertex's position in the degree list

      if node_degree != -1:
          # print("Searching for vertex", node.data, "with degree", vertices[node.data].degree)
          if degree_list[node_degree].exists(node.data) == False:
              # print("Vertex", node.data, "does not exist in degree list of", node_degree)
              degree_list[node_degree].printList(degree_list[node_degree].head)

          search_node = degree_list[node_degree].head
          # Decrease its degree
          vertices[node.data].degree -= 1

          # Find which node is representing this vertex
          while search_node.data != node.data:
            search_node = search_node.next

          # Delete it from current degree in dg list
          # print("Node degree is ", node_degree)
          degree_list[node_degree].deleteNode(search_node)
          # print("Removed ", search_node.data)
          # Place it in new DLL
          # print("Moving ", search_node.data, " into ", node_degree-1)
          degree_list[node_degree-1].append(search_node)
          # degree_list[node_degree-1].printList()

      node = node.next
  # print("List of deleted vertices: ")
  # for node in deleted_list.items:
  #     print(node.data, end=', ')
  # print()
  # print(deleted_degree_list.items)
  return vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted

def smallest_original_degree_last_vertex_ordering(vertices, degree_list, adj_list):
  # Vertices is a list of Vertex objects
  # Degree list is a list of DLL with integers
  # Essentially takes the create_graph_from_file_input output and performs
  # smallest last vertex ordering on it

  removed_vertices = 0
  deleted_list = Array()
  deleted_degree_list = Array() # Consisting of the degrees when removed
  max_degree_when_deleted = -1
  # Iteratively delete a vertex of smallest degree
  while removed_vertices != vertices.myLen():
    checking_degree = 0
    if degree_list[checking_degree].num_items > 0:
      # Remove head
      vertex_removed = degree_list[checking_degree].head
      # Remove the vertex in degree_list
      degree_list[checking_degree].deleteNode(vertex_removed)
      # Insert degree to degree list
      deleted_degree_list.insert(checking_degree)
      # Insert vertex to deleted list
      deleted_list.insert(vertex_removed)
      # Adjust the connected vertices' degrees, but don't move from current spot in degree list
      idx = vertices[vertex_removed].edge_list_ptr
      dll = adj_list[idx]
      if vertices[vertex_removed].degree > max_degree_when_deleted:
        max_degree_when_deleted = vertices[vertex_removed].degree

      node = dll.head
      while node:
        if vertices[node.data].degree >= 0:
          vertices[node.data].degree -= 1
        node = node.next


      removed_vertices += 1
    else:
      checking_degree += 1

  return vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted

def largest_last_vertex_ordering(vertices, degree_list, adj_list):
  # Vertices is a list of Vertex objects
  # Degree list is a list of DLL with integers
  # Essentially takes the create_graph_from_file_input output and performs
  # smallest last vertex ordering on it

  removed_vertices = 0
  deleted_list = Array()
  deleted_degree_list = Array() # Consisting of the degrees when removed
  max_degree_when_deleted = -1
  # Iteratively delete a vertex of smallest degree
  while removed_vertices != vertices.myLen():
    checking_degree = degree_list.myLen()-1
    if degree_list[checking_degree].num_items > 0:
      # Remove head
      vertex_removed = degree_list[checking_degree].head
      # Update the position in degree_list
      degree_list[checking_degree].deleteNode(vertex_removed)
      # Update the deleted degree list so I can find terminal clique later
      deleted_degree_list.insert(checking_degree)

      # Update the current degree
      if checking_degree > max_degree_when_deleted:
        max_degree_when_deleted = checking_degree

      # Update deleted list
      deleted_list.insert(vertex_removed)
      # Update vertex
      vertices[vertex_removed].degree = -1
      # Update number of removed vertices
      removed_vertices += 1

      # Update every connected vertex
      idx = vertices[vertex_removed].edge_list_ptr
      dll = adj_list[idx]

      node = dll.head
      while node:
        # NOTE do we actually have to remove curr vertex from conflicts' edge graphs?
        # I'm going to assume we don't
        if vertices[node.data].degree >= 0:
          vertices[node.data].degree -= 1

        # Update this vertex's position in the degree list
        search_node = degree_list[checking_degree].head

        # Find which node is representing this vertex
        while search_node.data is not node.data:
          search_node = search_node.next

        # Delete it from current degree in dg list
        degree_list[checking_degree].deleteNode(search_node)

        # Place it in new DLL
        degree_list[checking_degree].append(search_node)

        node = node.next
    else:
      checking_degree -= 1

  return vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted

def largest_original_degree_last_vertex_ordering(vertices, degree_list, adj_list):
  # Vertices is a list of Vertex objects
  # Degree list is a list of DLL with integers
  # Essentially takes the create_graph_from_file_input output and performs
  # smallest last vertex ordering on it

  removed_vertices = 0
  deleted_list = Array()
  deleted_degree_list = Array() # Consisting of the degrees when removed
  max_degree_when_deleted = -1
  # Iteratively delete a vertex of smallest degree
  while removed_vertices != vertices.myLen():
    checking_degree = degree_list.myLen()-1
    if degree_list[checking_degree].num_items > 0:
      # Remove head
      vertex_removed = degree_list[checking_degree].head
      # Remove the vertex in degree_list
      degree_list[checking_degree].deleteNode(vertex_removed)
      # Insert degree to degree list
      deleted_degree_list.insert(checking_degree)
      # Insert vertex to deleted list
      deleted_list.insert(vertex_removed)
      # Adjust the connected vertices' degrees, but don't move from current spot in degree list
      idx = vertices[vertex_removed].edge_list_ptr
      vertices[vertex_removed].degree = -1

      dll = adj_list[idx]
      if vertices[vertex_removed].degree > max_degree_when_deleted:
        max_degree_when_deleted = vertices[vertex_removed].degree

      node = dll.head
      while node:
        if vertices[node.data].degree >= 0:
          vertices[node.data-1].degree -= 1
        node = node.next

      removed_vertices += 1
    else:
      checking_degree -= 1

  return vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted

def random_skewed_low_degree_vertex_ordering(vertices, degree_list, adj_list):
  # Get number of vertices
  num_vertices = vertices.myLen()

  # Create "skewed" list.  Lower ID will have more entries
  skewed_list = Array()
  entries = vertices.myLen()
  for i in range(num_vertices):
    j = 0
    while j < entries:
      skewed_list.insert(i+1)
      j+=1

    entries -= 1

  # Perform the removal of vertices until none left
  vertices_removed = 0
  max_degree = -1
  deleted_degree_list = Array()
  deleted_list = Array()
  while vertices_removed < num_vertices:
    # Random uniformly select from this list
    selected_id = random.randint(0, skewed_list.myLen()+1)
    # Remove the selected ID occurences from the skewed list
    skewed_list.remove(selected_id)
    # Increase number of vertices removed
    vertices_removed += 1
    # Store degree when removed
    if vertices[selected_id].degree > max_degree:
      max_degree = vertices[selected_id].degree

    # Adjust the connected vertices' degrees, but don't move from current spot in degree list
    idx = vertices[selected_id].edge_list_ptr
    dll = adj_list[idx]

    # Append to deleted degree list
    deleted_degree_list.insert(vertices[selected_id].degree)
    # Append to deleted list
    deleted_list.insert(selected_id)
    # Set degree to removed
    vertices[selected_id].degree = -1

    # Check max degree
    if vertices[selected_id].degree > max_degree_when_deleted:
      max_degree_when_deleted = vertices[selected_id].degree

    node = dll.head
    while node:
      if vertices[node.data].degree >= 0:
        vertices[node.data].degree -= 1
      node = node.next

    vertices_removed += 1

  return vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted

def random_skewed_high_degree_vertex_ordering(vertices, degree_list, adj_list):
  # Get number of vertices
  num_vertices = vertices.myLen()

  # Create "skewed" list.  Lower ID will have more entries
  skewed_list = Array()
  entries = vertices.myLen()
  for i in reversed(range(num_vertices)):
    j = 0
    while j < entries:
      skewed_list.insert(i+1)
      j+=1

    entries -= 1

  # Perform the removal of vertices until none left
  vertices_removed = 0
  max_degree = -1
  deleted_degree_list = Array()
  deleted_list = Array()
  while vertices_removed < num_vertices:
      # Random uniformly select from this list
    selected_id = random.randint(0, skewed_list.myLen()+1)
    # Remove the selected ID occurences from the skewed list
    skewed_list.remove(selected_id)
    # Increase number of vertices removed
    vertices_removed += 1
    # Store degree when removed
    if vertices[selected_id].degree > max_degree:
      max_degree = vertices[selected_id].degree

    # Adjust the connected vertices' degrees, but don't move from current spot in degree list
    idx = vertices[selected_id].edge_list_ptr
    dll = adj_list[idx]

    # Append to deleted degree list
    deleted_degree_list.insert(vertices[selected_id].degree)
    # Append to deleted list
    deleted_list.insert(selected_id)
    # Set degree to removed
    vertices[selected_id].degree = -1

    # Check max degree
    if vertices[selected_id].degree > max_degree_when_deleted:
      max_degree_when_deleted = vertices[selected_id].degree

    node = dll.head
    while node:
      if vertices[node.data].degree >= 0:
        vertices[node.data].degree -= 1
      node = node.next

    vertices_removed += 1

  return vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted

def scan_and_assign_colors_random(vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted, adj_list):
  idx = deleted_degree_list.myLen() -1
  color_list = Array()
  for i in range(max_degree_when_deleted+1):
    color_list.insert(i)

  while idx >= 0:
    id = deleted_list # for the random I inserted the actual IDs

    # assign color

    # First, create a list of colors that are connected to vertex
    dll = adj_list[id]
    node = dll.head
    connected_colors = []
    while node:
      connected_color = vertices[none.data].color
      if connected_colors.exists(connected_color) is False:
        connected_colors.insert(connected_color)
      node = node.next

    # Loop through the possible colors, and pick first one
    chosen_color = -1
    for color in color_list.items:
      if connected_colors.exists(color) is False:
        chosen_color = color
        break


    if chosen_color == -1:
      print("Can't color graph using this number of colors.")

    vertices[id].color = chosen_color

  return vertices,

def scan_and_assign_colors(vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted, adj_list):
  # Go from end
  # print("============================")
  # print("Scan and assign colors")
  idx = deleted_degree_list.myLen() - 1

  # Find the terminal clique
  # Terminal clique begins where the degree value no longer increases when reversed
  # [ 0 1 2 1 3 2 1 0]
  # Reversed
  # [ 0 1 2 3 1 2 1 0]
  size_terminal_clique = 0
  clique_begins_idx = -1
  colors_needed = -1

  while idx > 0:
    if deleted_degree_list[idx] >= deleted_degree_list[idx - 1]:
      clique_begins_idx = idx
      colors_needed = deleted_degree_list.myLen() - idx
      break
    else:
      idx -=1
      size_terminal_clique += 1

  size_terminal_clique += 1
  # Color
  idx = deleted_degree_list.myLen() - 1
  # Degree when deleted + 1 is upper bound on the color
  # Check adjacent and use smallest that isn't in use

  while idx >= 0:
    id = deleted_list[idx].id # ID of vertex

    max_color = deleted_degree_list[idx] + 1
    color_list = Array()
    for i in range(max_color+1):
      color_list.insert(i)
    # Compare to adjacent vertices
    dll = adj_list[id]
    node = dll.head
    connected_colors = Array()
    while node:
      connected_color = vertices[node.id].color
      if connected_colors.exists(connected_color) is False:
        connected_colors.insert(connected_color)
      node = node.next

    # Iterated through connected colors
    # Find minimum
    # Loop through the possible colors, and pick first one
    chosen_color = -1
    # print("Color list items: ", color_list.items)
    for color in color_list.items:
      if connected_colors.exists(color) is False:
        chosen_color = color
        break


    if chosen_color == -1:
      print("Can't color graph using this number of colors.")

    vertices[id].color = chosen_color
    idx -= 1

  print("Final coloring")
  colored_list = Array()
  for id, v in enumerate(vertices):
      print(id, "has color", v.color)
      colored_list.insert(v.color)

  return vertices, max_degree_when_deleted, size_terminal_clique, colors_needed, colored_list

def part2(v, name):
    written_name = "./files/"+name+".txt"
    print("Creating graph from file created:", name)
    created_vertices, degree_list, adj_list = create_graph_from_file_input(written_name)

    P, E, adj_list = create_graph_from_adjacency_list(v, adj_list)

    # Validate they are the same
    # write_to_file(v, P, E, name+"_recreated")

    # Perform Ordering
    vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted = smallest_last_vertex_ordering(created_vertices, degree_list, adj_list)
    # Perform Coloring
    vertices, max_degree_when_deleted, size_terminal_clique, colors_needed, colored_list = scan_and_assign_colors(vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted, adj_list)

def part1():
    # What type of graph

    print("0: Cycle")
    print("1: Complete")
    print("2: Uniform random graph")
    print("3: Skewed low random graph")
    print("4: Skewed high random graph")

    graph_type = int(input("Input which graph you would like: "))

    creating_graphs = input("Creating plots (y/n): ")
    creating_hist = input("Creating histogram (y/n): ")
    v = -1
    name = ""
    if creating_graphs == "y":
        max_vert = int(input("Enter # vertices to go up to (increment 1000): "))
        times = Array()
        vertex_amount = Array()
        i = 1000
        e = i
        while i <= max_vert:
            start_time = time.time()
            _ = generate_graph(graph_type, i, e, False, False)
            times.insert(time.time() - start_time)
            vertex_amount.insert(i)
            i += 1000
            plot(vertex_amount, times, graph_type)
    else:
        v = int(input("Number of vertices: "))
        e = -1
        if graph_type > 1:
            e = int(input("Enter number of edges: "))
        if creating_hist == "y":
            name = generate_graph(graph_type, v, e, False, True)
        else:
            name = generate_graph(graph_type, v, e, write=True, histogram=False)
    return v, name

def scatter_plot(x, y, graph_type):
    plt.scatter(x,y)
    plt.ylabel("Degree when Deleted")
    plt.xlabel("Order Colored")
    name = get_graph_name(graph_type)
    plt.title(name)
    plt.savefig('./plots/scatter/'+name)
    plt.clf()

def part2plots():
    print("0: Cycle")
    print("1: Complete")
    print("2: Uniform random graph")
    print("3: Skewed low random graph")
    print("4: Skewed high random graph")

    graph_type = int(input("Input which graph you would like: "))

    name = ""
    max_vert = int(input("Enter # vertices to go up to (increment 1000): "))
    ordering_times = Array()
    coloring_times = Array()
    max_degrees = Array()
    terminal_sizes = Array()
    vertex_amount = Array()

    i = 1000
    e = i / 2
    while i <= max_vert:
        name = generate_graph(graph_type, i, e, True, False)

        vertex_amount.insert(i)
        # Read from file
        written_name = "./files/"+name+".txt"
        created_vertices, degree_list, adj_list = create_graph_from_file_input(written_name)
        P, E, adj_list = create_graph_from_adjacency_list(i, adj_list)
        # Time the ordering
        start_time = time.time()
        # Perform Ordering
        vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted = smallest_last_vertex_ordering(created_vertices, degree_list, adj_list)
        ordering_times.insert(time.time() - start_time)
        # Perform Coloring
        start_time = time.time()
        vertices, max_degree_when_deleted, size_terminal_clique, colors_needed, colored_list = scan_and_assign_colors(vertices, degree_list, deleted_degree_list, deleted_list, max_degree_when_deleted, adj_list)
        coloring_times.insert(time.time() - start_time)

        max_degrees.insert(max_degree_when_deleted)
        terminal_sizes.insert(size_terminal_clique)

        # print("term size:", size_terminal_clique)

        if i == max_vert:
            # Scatter plot
            degrees = reversed(deleted_degree_list.items)
            scatter_plot(x=list(range(1,len(deleted_degree_list.items)+1)), y=deleted_degree_list.items, graph_type=graph_type)

        i += 1000

    # Plots with lines
    plot(vertex_amount, ordering_times, graph_type, folder='order')
    plot(vertex_amount, coloring_times, graph_type, folder='color')
    plot(vertex_amount, terminal_sizes, graph_type, folder='terminal', make_table=False) # Need to do this on variety of graphs
    plot(vertex_amount, max_degrees, graph_type, folder='degree', make_table=False)

def main():
    print("1 - Part 1")
    print("2 - Part 2")
    print("3 - Testing plots for 2")
    choice = int(input("Enter your choice: "))
    if choice == 1:
        v, name = part1()
    if choice == 2:
        name = input("Enter file name: ")
        v = int(input("Enter number of vertices: "))
        part2(v, name)
    else:
        part2plots()



main()
